## Q1
OAuth 2.0に準拠するために用意するAPIを2つ、役割も含めて示してください。
### A
認可エンドポイント：認可コードを発行する
トークンエンドポイント：アクセストークン、リフレッシュトークンを発行する

## Q2
OAuth 2.0のシーケンスにて、ID/Passwordでログイン成功した後すぐにトークンを発行せず、わざわざ認可コードの往復を入れている理由を説明してください。
### A
Webアプリ側で取得した認可コードを使ってトークンエンドポイントを叩けば、アクセストークンなどをサーバー間通信によりセキュアに取得できるため。

## Q3
Webアプリのログイン画面でユーザーにIDとパスワードを入力してもらい、それをCognitoのクライアントSDKに渡して、そこからアクセストークン・リフレッシュトークン・IDトークンを受け取るという実装はOIDCに準拠していると言えますか？ 理由を添えてYES、Noで答えてください。
### A
No。
Webアプリ側でユーザーIDとパスワードを扱っているため。OIDCに準拠するにはWebアプリ側でユーザーIDとパスワードは扱ってはならない。

## Q4
IDトークンは、OAuth2.0 or OIDC どちらで登場するトークンですか？
### A
OIDC。

## Q5
IDトークン、アクセストークン、リフレッシュトークンのうち、一番漏れてはまずいトークンはどれですか？理由も添えて答えてください。
### A
リフレッシュトークン。
アクセストークンが発行でき、リソースにアクセスできるため。アクセストークンと比較し、期限も長いため影響が大きい。

## Q6
APIリクエスト時に送るものは、IDトークン、アクセストークンのどちらですか？
### A
アクセストークン。

## Q7
アクセストークンの有効期限を数ヶ月に設定してはいけない理由を説明してください。
### A
アクセストークンはすべてのAPIリクエストのヘッダーに乗るため、登場頻度が多く、仮にアクセストークンが漏れた場合、影響が大きいため。

## Q8
次のうち、HttpOnly属性をつけたCookieを操作できるのはどれですか？当てはまるものを全て答えてください。
1. API
2. Next.js サーバコンポーネント
3. ClientのJavaScript
4. CognitoのHosted UI
### A
1. API
2. Next.js サーバコンポーネント

## Q9
シーケンス図にて、認可コードをブラウザからではなく、サーバコンポーネントからCognitoに送っている理由をCookieのHttpOnly属性に注目して説明してください。
### A
HttpOnly属性はクライアント側から操作できず、サーバー側から操作するため、サーバコンポーネントからCognitoに送っている。

## Q10
アクセストークンの期限が有効であるかを確認する方法を以下のキーワードを用いて説明してください。
- JWT
- デコード
- ブラウザ側
### A
JWTのライブラリを使い、アクセストークンをブラウザ側でデコードして有効期限を確認する。